<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `v0_11` mod in crate `safe_transmute`."><meta name="keywords" content="rust, rustlang, rust-lang, v0_11"><title>safe_transmute::migration::v0_11 - Rust</title><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../dark.css"><link rel="stylesheet" type="text/css" href="../../../light.css" id="themeStyle"><script src="../../../storage.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="shortcut icon" href="../../../favicon.ico"><style type="text/css">#crate-search{background-image:url("../../../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../../safe_transmute/index.html'><div class='logo-container'><img src='../../../rust-logo.png' alt='logo'></div></a><p class='location'>Module v0_11</p><div class="sidebar-elems"><p class='location'><a href='../../index.html'>safe_transmute</a>::<wbr><a href='../index.html'>migration</a></p><script>window.sidebarCurrent = {name: 'v0_11', ty: 'mod', relpath: '../'};</script><script defer src="../sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../../../settings.html"><img src="../../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../../../src/safe_transmute/migration/v0_11.rs.html#1-125' title='goto source code'>[src]</a></span><span class='in-band'>Module <a href='../../index.html'>safe_transmute</a>::<wbr><a href='../index.html'>migration</a>::<wbr><a class="mod" href=''>v0_11</a></span></h1><div class='docblock'><p>Migrating to <code>safe-transmute</code> v0.11</p>
<p>This guide starts with a forewarning: <code>safe-transmute</code> had many safety issues before this version,
which means that there is a chance of your dependent project facing undefined behavior. Migrating
to version 0.11 is recommended as soon as possible, even if it might lead to a sub-optimal solution.</p>
<h2 id="organization" class="section-header"><a href="#organization">Organization</a></h2>
<p>The crate is now organized with the following major categories:</p>
<ul>
<li><code>base</code> contains all baseline conversion functions. They are only protected against out of boundary
access, like trying to create an 8-byte type from 7 bytes. However, they are still unsafe: any
attempt of transmuting data to an invalid memory representation is still undefined behavior.
Moreover, unaligned memory access is not prevented, and must be previously ensured by the caller.</li>
<li>The <code>trivial</code> module introduces the concept of being <em>trivially transmutable</em>, which
statically ensures that any bit combination makes a valid value for a given type. Basically,
if a type <code>T</code> can be filled with any arbitrary bits in its memory representation and still be
valid, then <code>T</code> is trivially transmutable. Most primitive types implement the <code>TriviallyTransmutable</code>
trait, as well as arrays of trivially transmutable types, but new types (such as repr-C structs)
need to <code>unsafe impl</code> it manually. Functions in this module are therefore safer than the baseline,
but are still unsafe because they do not check for memory alignment.</li>
<li><code>to_bytes</code> enables the opposite operation of reintepreting values as bytes. They are usually safe
unless when working with mutable slices, since they can break invariants of the source type.</li>
<li>The <code>bool</code> module ensures safe transmutation of bytes to boolean values.</li>
<li>That leaves the <code>full</code> functions at the crate root. These are transmutation functions with enough
checks to be considered safe to use in any circumstance. The operation may still arbitrarily
return (recoverable) errors due to unaligned data or incompatible vector transmutation targets,
but it will not eat your laundry, and helper functions are available to assist the user in
making some use cases work.</li>
</ul>
<p>Moreover, three utility modules have also been provided:</p>
<ul>
<li>The <code>guard</code> module contains the <strong>Guard API</strong>, which imposes slice boundary restrictions in a conversion.</li>
<li>The <code>align</code> module is where alignment checks are implemented.</li>
<li>The <code>util</code> module provides some independent helper functions.</li>
</ul>
<p>Generally, you are strongly advised to <em>stick to the functions provided at the crate root</em>.
These are re-exports from the <code>full</code>, <code>bool</code>, and <code>to_bytes</code> categories depending on their safety.</p>
<h2 id="transmuting-slices" class="section-header"><a href="#transmuting-slices">Transmuting slices</a></h2>
<p>One of the major use cases of the crate is to grab a slice of bytes and reinterpret it as a slice of
another type. This process is accompanied with a check for the source slice length, so that it
makes some sense as the target type. If you expect any number of elements of the target type, use
<code>transmute_many_permissive()</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">safe_transmute</span>::{<span class="ident">Error</span>, <span class="ident">transmute_many_permissive</span>};

<span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x12</span>, <span class="number">0x24</span>,
              <span class="number">0x00</span>]; <span class="comment">// 1 spare byte</span>

<span class="kw">match</span> <span class="ident">transmute_many_permissive</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>(<span class="ident">bytes</span>) {
    <span class="prelude-val">Ok</span>(<span class="ident">words</span>) <span class="op">=</span><span class="op">&gt;</span> {
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">words</span>,
                   [<span class="ident">u16</span>::<span class="ident">from_be</span>(<span class="number">0x0001</span>), <span class="ident">u16</span>::<span class="ident">from_be</span>(<span class="number">0x1224</span>)]);
    },
    <span class="prelude-val">Err</span>(<span class="ident">Error</span>::<span class="ident">Unaligned</span>(<span class="ident">e</span>)) <span class="op">=</span><span class="op">&gt;</span> {
        <span class="comment">// Copy needed, would otherwise trap on some archs</span>
        <span class="kw">let</span> <span class="ident">words</span> <span class="op">=</span> <span class="ident">e</span>.<span class="ident">copy</span>();
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="kw-2">*</span><span class="ident">words</span>,
                   [<span class="ident">u16</span>::<span class="ident">from_be</span>(<span class="number">0x0001</span>), <span class="ident">u16</span>::<span class="ident">from_be</span>(<span class="number">0x1224</span>)]);
    },
    <span class="prelude-val">Err</span>(<span class="ident">e</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="macro">panic</span><span class="macro">!</span>(<span class="string">&quot;Unexpected error: {}&quot;</span>, <span class="ident">e</span>),
}</pre></div>
<p><code>transmute_many_permissive()</code> is an alias for <code>transmute_many()</code> with <code>PermissiveGuard</code>
as the guard type parameter. If you expect at least 1 element, use <code>transmute_many()</code> with the
<code>SingleManyGuard</code> as the guard type. If you expect at least one element and no extraneous bytes, use
<code>transmute_many_pedantic()</code>, or <code>transmute_many()</code> with <code>PedanticGuard</code>.</p>
<p>As you can see, we had to manually handle the case where the slice of bytes is not well aligned for
reading target data, such as from <code>u8</code> to <code>u16</code>. If the slice's first element is not aligned for
reading <code>u16</code>s, the operation will just fail with <code>Error::Unaligned</code>. The only way to move on from
here is to copy the data (provided by the <code>Error::copy()</code> method).</p>
<p>The good news is that this boilerplate can be off-loaded to the <code>try_copy!</code> macro. Here's how you'll
often be doing transmutations:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">safe_transmute</span>::{<span class="ident">transmute_many_permissive</span>, <span class="ident">try_copy</span>};

<span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x12</span>, <span class="number">0x24</span>, <span class="number">0x00</span>];
<span class="kw">let</span> <span class="ident">words</span> <span class="op">=</span> <span class="macro">try_copy</span><span class="macro">!</span>(<span class="ident">transmute_many_permissive</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>(<span class="ident">bytes</span>));

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">words</span>, <span class="kw-2">&amp;</span>[<span class="ident">u16</span>::<span class="ident">from_be</span>(<span class="number">0x0001</span>), <span class="ident">u16</span>::<span class="ident">from_be</span>(<span class="number">0x1224</span>)]);</pre></div>
<p>You will also find <code>to_bytes</code>, <code>mut</code>, and <code>bool</code> variants of these functions. <code>transmute_to_bytes()</code> turns any slice into
a slice of bytes. Functions from the <code>*_mut()</code> family work with mutable slices. <code>transmute_bool()</code> checks whether all bytes
make valid boolean values beforehand.</p>
<h2 id="transmuting-vectors" class="section-header"><a href="#transmuting-vectors">Transmuting vectors</a></h2>
<p>You might have used <code>safe-transmute</code>'s vector transmutation functions. Well, it turns out that they are
<strong>incredibly unsafe</strong>, and hard to get right. This will be more complicated to migrate efficiently.
The new <code>transmute_vec()</code> only works under very restricted conditions: the <code>mem::align_of()</code> and <code>mem::size_of()</code> between
the source and target element types must match. Otherwise, a full copy of the vector must be made.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">safe_transmute</span>::{<span class="ident">transmute_vec</span>, <span class="ident">try_copy</span>};

<span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x12</span>, <span class="number">0x24</span>, <span class="number">0x00</span>];
<span class="kw">let</span> <span class="ident">words</span> <span class="op">=</span> <span class="macro">try_copy</span><span class="macro">!</span>(<span class="ident">transmute_vec</span>::<span class="op">&lt;</span><span class="kw">_</span>, <span class="ident">u16</span><span class="op">&gt;</span>(<span class="ident">bytes</span>)); <span class="comment">// !!! works, but will always copy</span>

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">words</span>, <span class="kw-2">&amp;</span>[<span class="ident">u16</span>::<span class="ident">from_be</span>(<span class="number">0x0001</span>), <span class="ident">u16</span>::<span class="ident">from_be</span>(<span class="number">0x1224</span>)]);</pre></div>
<p>Oftentimes, you'll just be avoiding vector transmutation entirely.</p>
<p>In order to avoid copies, you can allocate a vector of the target type <code>T</code>, transmute a mutable slice of the vector
into the source data type <code>S</code>, and write the data in there directly. This still requires both <code>S</code> and <code>T</code> to be
trivially transmutable in order to be within the compiler's safety guarantees, though.</p>
</div></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../../../";window.currentCrate = "safe_transmute";</script><script src="../../../main.js"></script><script defer src="../../../search-index.js"></script></body></html>