initSidebarItems({"fn":[["transmute_many","Transmute a byte slice into a sequence of values of the given type."],["transmute_many_mut","Transmute a mutable byte slice into a mutable sequence of values of the given type."],["transmute_many_pedantic","Transmute a byte slice into a sequence of values of the given type."],["transmute_many_pedantic_mut","Transmute a byte slice into a sequence of values of the given type."],["transmute_many_permissive","Transmute a byte slice into a sequence of values of the given type."],["transmute_many_permissive_mut","Transmute a byte slice into a sequence of values of the given type."],["transmute_one","Transmute a byte slice into a single instance of a trivially transmutable type."],["transmute_one_pedantic","Transmute a byte slice into a single instance of a trivially transmutable type."],["transmute_vec","Transform a vector into a vector of values with the given target type."]],"macro":[["try_copy","Retrieve the result of a transmutation, copying the data if it could not be safely performed due to memory alignment constraints."],["try_copy_unchecked","Retrieve the result of a non-trivial transmutation, copying the data if it could not be safely performed due to memory alignment constraints."]],"mod":[["align","Alignment checking primitives."],["base","Primitives for object and array transmutation."],["bool","Functions for safe transmutation to `bool`."],["error","Detectable and recoverable-from transmutation precondition errors."],["guard","The `guard` module exposes an API for memory boundary checking."],["to_bytes","Functions for transmutation from a concrete type to bytes."],["trivial","Transmutation of trivial objects"],["util","Module containing various utility functions."]]});