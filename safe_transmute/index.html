<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `safe_transmute` crate."><meta name="keywords" content="rust, rustlang, rust-lang, safe_transmute"><title>safe_transmute - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../safe_transmute/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Crate safe_transmute</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all safe_transmute's items</p></a><div class="block items"><ul><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#functions">Functions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'safe_transmute', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/safe_transmute/lib.rs.html#1-194' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>safe_transmute</a></span></h1><div class='docblock'><p>This crate contains checked implementations of transmutation procedures, some of which
ensure memory safety.</p>
<h2 id="crate-outline" class="section-header"><a href="#crate-outline">Crate outline</a></h2>
<p>The following modules are available:</p>
<ul>
<li>The functions in the <a href="base/index.html"><code>base</code></a> module are not inherently
safe, but just protected against out of boundary access (like trying to
create an 8-byte type from 7 bytes). These functions are as safe as
the data passed to them: any attempt of transmuting data to an invalid
memory representation is still undefined behavior. Moreover, unaligned
memory access is not prevented, and must be previously ensured by the
caller.</li>
<li>The <a href="guard/index.html"><code>guard</code></a> module contains the <strong>Guard API</strong>, which
imposes slice boundary restrictions in a conversion.</li>
<li>The <a href="trivial/index.html"><code>trivial</code></a> module introduces the
<a href="trivial/trait.TriviallyTransmutable.html"><code>TriviallyTransmutable</code></a>
trait, which statically ensures that any bit combination makes a valid
value for a given type. The functions in this module are safer than
<a href="base/index.html"><code>base</code></a>, but still do not prevent unaligned memory access.</li>
<li><a href="to_bytes/index.html"><code>to_bytes</code></a> enables the opposite operation of
reintepreting values as bytes.</li>
<li>The <a href="bool/index.html"><code>bool</code></a> module ensures safe transmutation of bytes
to boolean values.</li>
<li>At the root of this crate, there are transmutation functions with enough
checks to be considered safe to use in any circumstance. The operation may
still arbitrarily return (recoverable) errors due to unaligned data or
incompatible vector transmutation targets, but it will not eat your
laundry, and helper functions are available to assist the programmer in
making some use cases work.</li>
</ul>
<p>This crate can be used in a no-<code>std</code> environment by disabling the <code>std</code>
feature through specifying <code>default-features = false</code> on import.
However, <code>std</code> is only used for integration with <code>std::error::Error</code>.</p>
<p>Note, though, that funxions operating on items from <code>alloc</code> will also be disabled by this.
If your no-<code>std</code> environment has an <code>alloc</code> implementation, you will have to reenable them by using <code>features = [&quot;alloc&quot;]</code>.</p>
<h1 id="migrating" class="section-header"><a href="#migrating">Migrating</a></h1>
<p>If you've used <code>safe-transmute</code> before v0.11,
we recommend <a href="migration/v0_11/index.html">the v0.11 migration guide</a> to help get you going quickly.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<p>View bytes as a series of <code>u16</code>s, with a single-many boundary
guard (at least one value, extraneous bytes are allowed):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x12</span>, <span class="number">0x24</span>,
              <span class="number">0x00</span>]; <span class="comment">// 1 spare byte</span>
<span class="kw">match</span> <span class="ident">transmute_many</span>::<span class="op">&lt;</span><span class="ident">u16</span>, <span class="ident">SingleManyGuard</span><span class="op">&gt;</span>(<span class="ident">bytes</span>) {
    <span class="prelude-val">Ok</span>(<span class="ident">words</span>) <span class="op">=&gt;</span> {
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">words</span>,
                   [<span class="ident">u16</span>::<span class="ident">from_be</span>(<span class="number">0x0001</span>), <span class="ident">u16</span>::<span class="ident">from_be</span>(<span class="number">0x1224</span>)]);
    },
    <span class="prelude-val">Err</span>(<span class="ident">Error</span>::<span class="ident">Unaligned</span>(<span class="ident">e</span>)) <span class="op">=&gt;</span> {
        <span class="comment">// Copy needed, would otherwise trap on some archs</span>
        <span class="kw">let</span> <span class="ident">words</span> <span class="op">=</span> <span class="ident">e</span>.<span class="ident">copy</span>();
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="kw-2">*</span><span class="ident">words</span>,
                   [<span class="ident">u16</span>::<span class="ident">from_be</span>(<span class="number">0x0001</span>), <span class="ident">u16</span>::<span class="ident">from_be</span>(<span class="number">0x1224</span>)]);
    },
    <span class="prelude-val">Err</span>(<span class="ident">e</span>) <span class="op">=&gt;</span> <span class="macro">panic</span><span class="macro">!</span>(<span class="string">&quot;Unexpected error: {}&quot;</span>, <span class="ident">e</span>),
}</pre></div>
<p>Since one may not always be able to ensure that a slice of bytes is well
aligned for reading data of different constraints, such as from <code>u8</code> to
<code>u16</code>, the operation may fail without a trivial way of preventing it.</p>
<p>As a remedy, the data can instead be copied byte-for-byte to a new vector,
with the help of the <a href="macro.try_copy.html"><code>try_copy!()</code></a> macro.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x12</span>, <span class="number">0x24</span>, <span class="number">0x00</span>];
<span class="kw">let</span> <span class="ident">words</span> <span class="op">=</span> <span class="macro">try_copy</span><span class="macro">!</span>(<span class="ident">transmute_many</span>::<span class="op">&lt;</span><span class="ident">u16</span>, <span class="ident">SingleManyGuard</span><span class="op">&gt;</span>(<span class="ident">bytes</span>));

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="kw-2">*</span><span class="ident">words</span>,
           [<span class="ident">u16</span>::<span class="ident">from_be</span>(<span class="number">0x0001</span>), <span class="ident">u16</span>::<span class="ident">from_be</span>(<span class="number">0x1224</span>)]);</pre></div>
<p>View all bytes as a series of <code>u16</code>s:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Assuming little-endian</span>
<span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x12</span>, <span class="number">0x34</span>];
<span class="kw">let</span> <span class="ident">words</span> <span class="op">=</span> <span class="macro">try_copy</span><span class="macro">!</span>(<span class="ident">transmute_many_pedantic</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>(<span class="ident">bytes</span>));

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="kw-2">*</span><span class="ident">words</span>, [<span class="number">0x0100</span>, <span class="number">0x3412</span>]);</pre></div>
<p>View a byte slice as a single <code>f64</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">transmute_one</span>::<span class="op">&lt;</span><span class="ident">f64</span><span class="op">&gt;</span>(
    <span class="kw-2">&amp;</span>[<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,
      <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>])<span class="question-mark">?</span>,
    <span class="number">2.0</span>);</pre></div>
<p>View a series of <code>u16</code>s as bytes:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">transmute_to_bytes</span>(<span class="kw-2">&amp;</span>[<span class="number">0x0001u16</span>,
                                <span class="number">0x1234u16</span>]),
           <span class="kw-2">&amp;</span>[<span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x34</span>, <span class="number">0x12</span>].<span class="ident">le_to_native</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>());</pre></div>
</div><h2 id='reexports' class='section-header'><a href="#reexports">Re-exports</a></h2>
<table><tr><td><code>pub use self::guard::<a class="struct" href="../safe_transmute/guard/struct.SingleValueGuard.html" title="struct safe_transmute::guard::SingleValueGuard">SingleValueGuard</a>;</code></td></tr><tr><td><code>pub use self::guard::<a class="struct" href="../safe_transmute/guard/struct.PermissiveGuard.html" title="struct safe_transmute::guard::PermissiveGuard">PermissiveGuard</a>;</code></td></tr><tr><td><code>pub use self::guard::<a class="struct" href="../safe_transmute/guard/struct.SingleManyGuard.html" title="struct safe_transmute::guard::SingleManyGuard">SingleManyGuard</a>;</code></td></tr><tr><td><code>pub use self::guard::<a class="struct" href="../safe_transmute/guard/struct.PedanticGuard.html" title="struct safe_transmute::guard::PedanticGuard">PedanticGuard</a>;</code></td></tr><tr><td><code>pub use self::guard::<a class="trait" href="../safe_transmute/guard/trait.Guard.html" title="trait safe_transmute::guard::Guard">Guard</a>;</code></td></tr><tr><td><code>pub use self::error::<a class="struct" href="../safe_transmute/error/struct.UnalignedError.html" title="struct safe_transmute::error::UnalignedError">UnalignedError</a>;</code></td></tr><tr><td><code>pub use self::error::<a class="enum" href="../safe_transmute/error/enum.ErrorReason.html" title="enum safe_transmute::error::ErrorReason">ErrorReason</a>;</code></td></tr><tr><td><code>pub use self::error::<a class="struct" href="../safe_transmute/error/struct.GuardError.html" title="struct safe_transmute::error::GuardError">GuardError</a>;</code></td></tr><tr><td><code>pub use self::error::<a class="enum" href="../safe_transmute/error/enum.Error.html" title="enum safe_transmute::error::Error">Error</a>;</code></td></tr><tr><td><code>pub use self::error::<a class="struct" href="../safe_transmute/error/struct.IncompatibleVecTargetError.html" title="struct safe_transmute::error::IncompatibleVecTargetError">IncompatibleVecTargetError</a>;</code></td></tr><tr><td><code>pub use self::trivial::<a class="trait" href="../safe_transmute/trivial/trait.TriviallyTransmutable.html" title="trait safe_transmute::trivial::TriviallyTransmutable">TriviallyTransmutable</a>;</code></td></tr><tr><td><code>pub use self::trivial::<a class="fn" href="../safe_transmute/trivial/fn.align_to_mut.html" title="fn safe_transmute::trivial::align_to_mut">align_to_mut</a>;</code></td></tr><tr><td><code>pub use self::trivial::<a class="fn" href="../safe_transmute/trivial/fn.align_to.html" title="fn safe_transmute::trivial::align_to">align_to</a>;</code></td></tr><tr><td><code>pub use self::to_bytes::<a class="fn" href="../safe_transmute/to_bytes/fn.transmute_one_to_bytes_mut.html" title="fn safe_transmute::to_bytes::transmute_one_to_bytes_mut">transmute_one_to_bytes_mut</a>;</code></td></tr><tr><td><code>pub use self::to_bytes::<a class="fn" href="../safe_transmute/to_bytes/fn.transmute_one_to_bytes.html" title="fn safe_transmute::to_bytes::transmute_one_to_bytes">transmute_one_to_bytes</a>;</code></td></tr><tr><td><code>pub use self::to_bytes::<a class="fn" href="../safe_transmute/to_bytes/fn.transmute_to_bytes_mut.html" title="fn safe_transmute::to_bytes::transmute_to_bytes_mut">transmute_to_bytes_mut</a>;</code></td></tr><tr><td><code>pub use self::to_bytes::<a class="fn" href="../safe_transmute/to_bytes/fn.transmute_to_bytes.html" title="fn safe_transmute::to_bytes::transmute_to_bytes">transmute_to_bytes</a>;</code></td></tr><tr><td><code>pub use self::to_bytes::<a class="fn" href="../safe_transmute/to_bytes/fn.transmute_to_bytes_vec.html" title="fn safe_transmute::to_bytes::transmute_to_bytes_vec">transmute_to_bytes_vec</a>;</code></td></tr><tr><td><code>pub use self::bool::<a class="fn" href="../safe_transmute/bool/fn.transmute_bool_vec_permissive.html" title="fn safe_transmute::bool::transmute_bool_vec_permissive">transmute_bool_vec_permissive</a>;</code></td></tr><tr><td><code>pub use self::bool::<a class="fn" href="../safe_transmute/bool/fn.transmute_bool_vec_pedantic.html" title="fn safe_transmute::bool::transmute_bool_vec_pedantic">transmute_bool_vec_pedantic</a>;</code></td></tr><tr><td><code>pub use self::bool::<a class="fn" href="../safe_transmute/bool/fn.transmute_bool_permissive.html" title="fn safe_transmute::bool::transmute_bool_permissive">transmute_bool_permissive</a>;</code></td></tr><tr><td><code>pub use self::bool::<a class="fn" href="../safe_transmute/bool/fn.transmute_bool_pedantic.html" title="fn safe_transmute::bool::transmute_bool_pedantic">transmute_bool_pedantic</a>;</code></td></tr></table><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table><tr class='module-item'><td><a class="mod" href="align/index.html" title='safe_transmute::align mod'>align</a></td><td class='docblock-short'><p>Alignment checking primitives.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="base/index.html" title='safe_transmute::base mod'>base</a></td><td class='docblock-short'><p>Primitives for object and array transmutation.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="bool/index.html" title='safe_transmute::bool mod'>bool</a></td><td class='docblock-short'><p>Functions for safe transmutation to <code>bool</code>.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="error/index.html" title='safe_transmute::error mod'>error</a></td><td class='docblock-short'><p>Detectable and recoverable-from transmutation precondition errors.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="guard/index.html" title='safe_transmute::guard mod'>guard</a></td><td class='docblock-short'><p>The <code>guard</code> module exposes an API for memory boundary checking.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="migration/index.html" title='safe_transmute::migration mod'>migration</a></td><td class='docblock-short'><p>Migration guides.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="to_bytes/index.html" title='safe_transmute::to_bytes mod'>to_bytes</a></td><td class='docblock-short'><p>Functions for transmutation <em>from</em> a concrete type <em>to</em> bytes.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="trivial/index.html" title='safe_transmute::trivial mod'>trivial</a></td><td class='docblock-short'><p>Transmutation of trivial objects</p>
</td></tr><tr class='module-item'><td><a class="mod" href="util/index.html" title='safe_transmute::util mod'>util</a></td><td class='docblock-short'><p>Module containing various utility functions.</p>
</td></tr></table><h2 id='macros' class='section-header'><a href="#macros">Macros</a></h2>
<table><tr class='module-item'><td><a class="macro" href="macro.try_copy.html" title='safe_transmute::try_copy macro'>try_copy</a></td><td class='docblock-short'><p>Retrieve the result of a transmutation,
copying the data if it could not be safely performed due to memory alignment constraints.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.try_copy_unchecked.html" title='safe_transmute::try_copy_unchecked macro'>try_copy_unchecked</a></td><td class='docblock-short'><p>Retrieve the result of a non-trivial transmutation,
copying the data if it could not be safely performed due to memory alignment constraints.</p>
</td></tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table><tr class='module-item'><td><a class="fn" href="fn.transmute_many.html" title='safe_transmute::transmute_many fn'>transmute_many</a></td><td class='docblock-short'><p>Transmute a byte slice into a sequence of values of the given type.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.transmute_many_mut.html" title='safe_transmute::transmute_many_mut fn'>transmute_many_mut</a></td><td class='docblock-short'><p>Transmute a mutable byte slice into a mutable sequence of values of the given type.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.transmute_many_pedantic.html" title='safe_transmute::transmute_many_pedantic fn'>transmute_many_pedantic</a></td><td class='docblock-short'><p>Transmute a byte slice into a sequence of values of the given type.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.transmute_many_pedantic_mut.html" title='safe_transmute::transmute_many_pedantic_mut fn'>transmute_many_pedantic_mut</a></td><td class='docblock-short'><p>Transmute a byte slice into a sequence of values of the given type.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.transmute_many_permissive.html" title='safe_transmute::transmute_many_permissive fn'>transmute_many_permissive</a></td><td class='docblock-short'><p>Transmute a byte slice into a sequence of values of the given type.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.transmute_many_permissive_mut.html" title='safe_transmute::transmute_many_permissive_mut fn'>transmute_many_permissive_mut</a></td><td class='docblock-short'><p>Transmute a byte slice into a sequence of values of the given type.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.transmute_one.html" title='safe_transmute::transmute_one fn'>transmute_one</a></td><td class='docblock-short'><p>Transmute a byte slice into a single instance of a trivially transmutable type.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.transmute_one_pedantic.html" title='safe_transmute::transmute_one_pedantic fn'>transmute_one_pedantic</a></td><td class='docblock-short'><p>Transmute a byte slice into a single instance of a trivially transmutable type.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.transmute_vec.html" title='safe_transmute::transmute_vec fn'>transmute_vec</a></td><td class='docblock-short'><p>Transform a vector into a vector of values with the given target type.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "safe_transmute";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>