var N=null,E="",T="t",U="u",searchIndex={};
var R=["Transmute a byte slice into a sequence of values of the…","result","error","Transmute a byte slice into a single instance of a…","triviallytransmutable","Convert a byte slice into a single instance of a…","transmute_many","transmute_many_mut","transmute_many_permissive","View a byte slice as a slice of an arbitrary type.","transmute_vec","safe_transmute","View a byte slice as a slice of boolean values.","unalignederror","copy_unchecked","Create a copy of the source data, transmuted into a…","Create a copy of the data, transmuted into a new vector.…","guarderror","Transmute the slice to a slice of another type, ensuring…","View a byte slice as a slice of a trivially transmutable…","Transform a vector into a vector of another element type.","Transmute a single instance of a trivially transmutable…","Transmute a slice of arbitrary types into a slice of their…","safe_transmute::error","to_string","to_owned","clone_into","try_from","try_into","borrow_mut","type_id","borrow","typeid","safe_transmute::guard","incompatiblevectargeterror","errorreason","formatter","description","GuardError","UnalignedError","IncompatibleVecTargetError","ErrorReason","SingleValueGuard","PedanticGuard","AllOrNothingGuard","SingleManyGuard","PermissiveGuard"];

searchIndex["safe_transmute"]={"doc":"This crate contains checked implementations of…","i":[[5,"transmute_many_permissive_mut",R[11],R[0],N,[[],[[R[2],["u8"]],[R[1],[R[2]]]]]],[5,"transmute_many_pedantic_mut",E,R[0],N,[[],[[R[2],["u8"]],[R[1],[R[2]]]]]],[5,R[8],E,R[0],N,[[],[[R[2],["u8"]],[R[1],[R[2]]]]]],[5,"transmute_many_pedantic",E,R[0],N,[[],[[R[2],["u8"]],[R[1],[R[2]]]]]],[5,"transmute_one_pedantic",E,R[3],N,[[],[[R[1],[R[2]]],[R[2],["u8"]],[R[4]]]]],[5,R[6],E,R[0],N,[[],[[R[2],["u8"]],[R[1],[R[2]]]]]],[5,R[7],E,"Transmute a mutable byte slice into a mutable sequence of…",N,[[],[[R[2],["u8"]],[R[1],[R[2]]]]]],[5,"transmute_one",E,R[3],N,[[],[[R[1],[R[2]]],[R[2],["u8"]],[R[4]]]]],[5,R[10],E,"Transform a vector into a vector of values with the given…",N,[[["vec"],[R[4]]],[["vec"],[R[1],["vec",R[2]]],[R[2]]]]],[0,"base",E,"Primitives for object and array transmutation.",N,N],[5,"from_bytes","safe_transmute::base",R[5],N,[[],[[R[1],[R[2]]],["copy"],[R[2],["u8"]]]]],[5,"from_bytes_pedantic",E,R[5],N,[[],[[R[1],[R[2]]],["copy"],[R[2],["u8"]]]]],[5,R[6],E,R[9],N,[[],[[R[2],["u8"]],[R[1],[R[2]]]]]],[5,R[7],E,"View a mutable byte slice as a slice of an arbitrary type.",N,[[],[[R[2],["u8"]],[R[1],[R[2]]]]]],[5,R[8],E,R[9],N,[[]]],[5,R[10],E,R[20],N,[[["vec"]],["vec"]]],[0,"bool",R[11],"Functions for safe transmutation to `bool`.",N,N],[5,"bytes_are_bool","safe_transmute::bool","Makes sure that the bytes represent a sequence of valid…",N,[[],["bool"]]],[5,"transmute_bool_permissive",E,R[12],N,[[],[[R[2],["u8","bool"]],[R[1],[R[2]]]]]],[5,"transmute_bool_pedantic",E,R[12],N,[[],[[R[2],["u8","bool"]],[R[1],[R[2]]]]]],[5,"transmute_bool_vec_permissive",E,"Trasform a byte vector into a vector of bool.",N,[[["vec",["u8"]],["u8"]],[["vec",["bool"]],[R[1],["vec",R[2]]],[R[2],["u8","bool"]]]]],[5,"transmute_bool_vec_pedantic",E,"Transform a byte vector into a vector of bool.",N,[[["vec",["u8"]],["u8"]],[["vec",["bool"]],[R[1],["vec",R[2]]],[R[2],["u8","bool"]]]]],[0,"util",R[11],"Module containing various utility functions.",N,N],[5,"designalise_f32","safe_transmute::util","If the specified 32-bit float is a signaling NaN, make it…",N,[[["f32"]],["f32"]]],[5,"designalise_f64",E,"If the specified 64-bit float is a signaling NaN, make it…",N,[[["f64"]],["f64"]]],[5,"from_bits_f32_designalised",E,"Reinterpret the given bits as a 32-bit float. If the…",N,[[["u32"]],["f32"]]],[5,"from_bits_f64_designalised",E,"Reinterpret the given bits as a 64-bit float. If the…",N,[[["u64"]],["f64"]]],[0,"align",R[11],"Alignment checking primitives.",N,N],[5,"check_alignment","safe_transmute::align","Check whether the given data slice of `S`s is properly…",N,[[],[[R[1],[R[13]]],[R[13]]]]],[5,"check_alignment_mut",E,"Check whether the given mutable data slice of `S`s is…",N,[[],[[R[13]],[R[1],[R[13]]]]]],[0,R[2],R[11],"Detectable and recoverable-from transmutation precondition…",N,N],[3,R[38],R[23],"A slice boundary guard error, usually created by a `Guard`.",N,N],[12,"required",E,"The required amount of bytes for transmutation.",0,N],[12,"actual",E,"The actual amount of bytes.",0,N],[12,"reason",E,"Why this `required`/`actual`/`T` combo is an error.",0,N],[3,R[39],E,"Unaligned memory access error.",N,N],[12,"offset",E,"The required amount of bytes to discard at the front for…",1,N],[12,"source",E,"A slice of the original source data.",1,N],[3,R[40],E,"Incompatible vector transmutation error.",N,N],[12,"vec",E,"The original vector.",2,N],[4,"Error",E,"A transmutation error. This type describes possible errors…",N,N],[13,"Guard",E,"The data does not respect the target type's boundaries.",3,N],[13,"Unaligned",E,"The given data slice is not properly aligned for the…",3,N],[13,"IncompatibleVecTarget",E,"The data vector's element type does not have the same size…",3,N],[13,"InvalidValue",E,"The data contains an invalid value for the target type.",3,N],[4,R[41],E,"How the type's size compares to the received byte count…",N,N],[13,"NotEnoughBytes",E,"Too few bytes to fill even one instance of a type.",4,N],[13,"TooManyBytes",E,"Too many bytes to fill a type.",4,N],[13,"InexactByteCount",E,"The byte amount received is not the same as the type's size.",4,N],[11,"copy",E,"Reattempt the failed transmutation if the failure was…",3,[[],[[R[1],["vec",R[2]]],["vec"],[R[2]]]]],[11,R[14],E,"Reattempt the failed non-trivial transmutation if the…",3,[[],[[R[1],["vec",R[2]]],["vec"],[R[2]]]]],[11,"without_src",E,"Create a new error which discards runtime information…",3,[[],[R[2]]]],[11,R[37],E,"Retrieve a human readable description of the reason.",4,[[],["str"]]],[11,"new",E,E,1,[[["usize"]],["self"]]],[11,R[14],E,R[15],1,[[["self"]],["vec"]]],[11,"copy",E,R[15],1,[[["self"]],["vec"]]],[11,"new",E,"Create an error with the given vector.",2,[[["vec"]],["self"]]],[11,R[14],E,R[16],2,[[["self"]],["vec"]]],[11,"copy",E,R[16],2,[[["self"]],["vec"]]],[0,"guard",R[11],"The `guard` module exposes an API for memory boundary…",N,N],[3,R[42],R[33],"Single value guard: The byte slice must have exactly…",N,N],[3,R[43],E,"Pedantic guard: The byte slice must have at least enough…",N,N],[3,R[44],E,"An all-or-nothing guard: The byte slice should not have…",N,N],[3,R[45],E,"A single-or-many guard: The byte slice must have at least…",N,N],[3,R[46],E,"Permissive guard: The resulting slice would have as many…",N,N],[8,"Guard",E,"The trait describes types which define boundary checking…",N,N],[10,"check",E,"Check the size of the given byte slice against a…",5,[[],[[R[17]],[R[1],[R[17]]]]]],[0,"trivial",R[11],"Transmutation of trivial objects",N,N],[5,"align_to","safe_transmute::trivial",R[18],N,[[]]],[5,"align_to_mut",E,R[18],N,[[]]],[5,"transmute_trivial",E,R[3],N,[[],[[R[1],[R[2]]],[R[2],["u8"]],[R[4]]]]],[5,"transmute_trivial_pedantic",E,R[3],N,[[],[[R[1],[R[2]]],[R[2],["u8"]],[R[4]]]]],[5,"transmute_trivial_many",E,R[3],N,[[],[[R[2],["u8"]],[R[1],[R[2]]]]]],[5,"transmute_trivial_many_mut",E,R[3],N,[[],[[R[2],["u8"]],[R[1],[R[2]]]]]],[5,"guarded_transmute_pod_many_permissive",E,R[19],N,[[],[[R[2],["u8"]],[R[1],[R[2]]]]]],[5,"guarded_transmute_pod_many_pedantic",E,R[19],N,[[],[[R[2],["u8"]],[R[1],[R[2]]]]]],[5,"transmute_trivial_vec",E,R[20],N,[[["vec"],[R[4]]],[["vec"],[R[4]]]]],[8,"TriviallyTransmutable",E,"Type that can be constructed from any combination of bytes.",N,N],[0,"to_bytes",R[11],"Functions for transmutation from a concrete type to bytes.",N,N],[5,"transmute_to_bytes_unchecked","safe_transmute::to_bytes","Transmute a single instance of an arbitrary type into a…",N,[[["s"]]]],[5,"transmute_to_bytes_unchecked_mut",E,"Transmute a single mutable instance of an arbitrary type…",N,[[["s"]]]],[5,"transmute_to_bytes_many_unchecked",E,R[22],N,[[]]],[5,"transmute_to_bytes_many_unchecked_mut",E,"Transmute a mutable slice of arbitrary types into a…",N,[[]]],[5,"transmute_one_to_bytes",E,R[21],N,[[["s"]]]],[5,"transmute_one_to_bytes_mut",E,R[21],N,[[["s"]]]],[5,"transmute_to_bytes",E,R[22],N,[[]]],[5,"transmute_to_bytes_mut",E,"Transmute a mutable slice of a trivially transmutable type…",N,[[]]],[5,"guarded_transmute_to_bytes_pod_many",E,R[22],N,[[]]],[5,"transmute_to_bytes_vec",E,"Transmute a vector of elements of an arbitrary type into a…",N,[[["vec"],[R[4]]],[["vec",["u8"]],[R[1],["vec",R[2]]],[R[2],["u8"]]]]],[0,"migration",R[11],"Migration guides.",N,N],[0,"v0_11","safe_transmute::migration","Migrating to `safe-transmute` v0.11",N,N],[14,"try_copy",R[11],"Retrieve the result of a transmutation, copying the data…",N,N],[14,"try_copy_unchecked",E,"Retrieve the result of a non-trivial transmutation,…",N,N],[11,"from",R[23],E,0,[[[T]],[T]]],[11,R[24],E,E,0,[[["self"]],["string"]]],[11,R[25],E,E,0,[[["self"]],[T]]],[11,R[26],E,E,0,[[["self"],[T]]]],[11,"into",E,E,0,[[],[U]]],[11,R[27],E,E,0,[[[U]],[R[1]]]],[11,R[28],E,E,0,[[],[R[1]]]],[11,R[29],E,E,0,[[["self"]],[T]]],[11,R[31],E,E,0,[[["self"]],[T]]],[11,R[30],E,E,0,[[["self"]],[R[32]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[24],E,E,1,[[["self"]],["string"]]],[11,R[25],E,E,1,[[["self"]],[T]]],[11,R[26],E,E,1,[[["self"],[T]]]],[11,"into",E,E,1,[[],[U]]],[11,R[27],E,E,1,[[[U]],[R[1]]]],[11,R[28],E,E,1,[[],[R[1]]]],[11,R[29],E,E,1,[[["self"]],[T]]],[11,R[31],E,E,1,[[["self"]],[T]]],[11,R[30],E,E,1,[[["self"]],[R[32]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[24],E,E,2,[[["self"]],["string"]]],[11,R[25],E,E,2,[[["self"]],[T]]],[11,R[26],E,E,2,[[["self"],[T]]]],[11,"into",E,E,2,[[],[U]]],[11,R[27],E,E,2,[[[U]],[R[1]]]],[11,R[28],E,E,2,[[],[R[1]]]],[11,R[29],E,E,2,[[["self"]],[T]]],[11,R[31],E,E,2,[[["self"]],[T]]],[11,R[30],E,E,2,[[["self"]],[R[32]]]],[11,"from",E,E,3,[[[T]],[T]]],[11,R[24],E,E,3,[[["self"]],["string"]]],[11,R[25],E,E,3,[[["self"]],[T]]],[11,R[26],E,E,3,[[["self"],[T]]]],[11,"into",E,E,3,[[],[U]]],[11,R[27],E,E,3,[[[U]],[R[1]]]],[11,R[28],E,E,3,[[],[R[1]]]],[11,R[29],E,E,3,[[["self"]],[T]]],[11,R[31],E,E,3,[[["self"]],[T]]],[11,R[30],E,E,3,[[["self"]],[R[32]]]],[11,"from",E,E,4,[[[T]],[T]]],[11,R[25],E,E,4,[[["self"]],[T]]],[11,R[26],E,E,4,[[["self"],[T]]]],[11,"into",E,E,4,[[],[U]]],[11,R[27],E,E,4,[[[U]],[R[1]]]],[11,R[28],E,E,4,[[],[R[1]]]],[11,R[29],E,E,4,[[["self"]],[T]]],[11,R[31],E,E,4,[[["self"]],[T]]],[11,R[30],E,E,4,[[["self"]],[R[32]]]],[11,"from",R[33],E,6,[[[T]],[T]]],[11,"into",E,E,6,[[],[U]]],[11,R[27],E,E,6,[[[U]],[R[1]]]],[11,R[28],E,E,6,[[],[R[1]]]],[11,R[29],E,E,6,[[["self"]],[T]]],[11,R[31],E,E,6,[[["self"]],[T]]],[11,R[30],E,E,6,[[["self"]],[R[32]]]],[11,"from",E,E,7,[[[T]],[T]]],[11,"into",E,E,7,[[],[U]]],[11,R[27],E,E,7,[[[U]],[R[1]]]],[11,R[28],E,E,7,[[],[R[1]]]],[11,R[29],E,E,7,[[["self"]],[T]]],[11,R[31],E,E,7,[[["self"]],[T]]],[11,R[30],E,E,7,[[["self"]],[R[32]]]],[11,"from",E,E,8,[[[T]],[T]]],[11,"into",E,E,8,[[],[U]]],[11,R[27],E,E,8,[[[U]],[R[1]]]],[11,R[28],E,E,8,[[],[R[1]]]],[11,R[29],E,E,8,[[["self"]],[T]]],[11,R[31],E,E,8,[[["self"]],[T]]],[11,R[30],E,E,8,[[["self"]],[R[32]]]],[11,"from",E,E,9,[[[T]],[T]]],[11,"into",E,E,9,[[],[U]]],[11,R[27],E,E,9,[[[U]],[R[1]]]],[11,R[28],E,E,9,[[],[R[1]]]],[11,R[29],E,E,9,[[["self"]],[T]]],[11,R[31],E,E,9,[[["self"]],[T]]],[11,R[30],E,E,9,[[["self"]],[R[32]]]],[11,"from",E,E,10,[[[T]],[T]]],[11,"into",E,E,10,[[],[U]]],[11,R[27],E,E,10,[[[U]],[R[1]]]],[11,R[28],E,E,10,[[],[R[1]]]],[11,R[29],E,E,10,[[["self"]],[T]]],[11,R[31],E,E,10,[[["self"]],[T]]],[11,R[30],E,E,10,[[["self"]],[R[32]]]],[11,"check",E,E,6,[[],[[R[17]],[R[1],[R[17]]]]]],[11,"check",E,E,7,[[],[[R[17]],[R[1],[R[17]]]]]],[11,"check",E,E,8,[[],[[R[17]],[R[1],[R[17]]]]]],[11,"check",E,E,9,[[],[[R[17]],[R[1],[R[17]]]]]],[11,"check",E,E,10,[[],[[R[17]],[R[1],[R[17]]]]]],[11,"from",R[23],E,3,[[[R[17]]],["self"]]],[11,"from",E,E,3,[[[R[13]]],["self"]]],[11,"from",E,E,3,[[[R[34]]],["self"]]],[11,"clone",E,E,3,[[["self"]],[R[2]]]],[11,"clone",E,E,0,[[["self"]],[R[17]]]],[11,"clone",E,E,4,[[["self"]],[R[35]]]],[11,"clone",E,E,1,[[["self"]],[R[13]]]],[11,"clone",E,E,2,[[["self"]],[R[34]]]],[11,"eq",E,E,3,[[["self"],[R[2]]],["bool"]]],[11,"ne",E,E,3,[[["self"],[R[2]]],["bool"]]],[11,"eq",E,E,0,[[["self"],[R[17]]],["bool"]]],[11,"ne",E,E,0,[[["self"],[R[17]]],["bool"]]],[11,"eq",E,E,4,[[["self"],[R[35]]],["bool"]]],[11,"eq",E,E,1,[[["self"],[R[13]]],["bool"]]],[11,"ne",E,E,1,[[["self"],[R[13]]],["bool"]]],[11,"eq",E,E,2,[[["self"],[R[34]]],["bool"]]],[11,"ne",E,E,2,[[["self"],[R[34]]],["bool"]]],[11,"fmt",E,E,3,[[["self"],[R[36]]],[R[1]]]],[11,"fmt",E,E,0,[[["self"],[R[36]]],[R[1]]]],[11,"fmt",E,E,1,[[["self"],[R[36]]],[R[1]]]],[11,"fmt",E,E,2,[[["self"],[R[36]]],[R[1]]]],[11,"fmt",E,E,3,[[["self"],[R[36]]],[R[1]]]],[11,"fmt",E,E,0,[[["self"],[R[36]]],[R[1]]]],[11,"fmt",E,E,4,[[["self"],[R[36]]],[R[1]]]],[11,"fmt",E,E,1,[[["self"],[R[36]]],[R[1]]]],[11,"fmt",E,E,2,[[["self"],[R[36]]],[R[1]]]],[11,"hash",E,E,3,[[["self"],["__hst"]]]],[11,"hash",E,E,0,[[["self"],["__h"]]]],[11,"hash",E,E,4,[[["self"],["__h"]]]],[11,"hash",E,E,1,[[["self"],["__hst"]]]],[11,"hash",E,E,2,[[["self"],["__hst"]]]],[11,R[37],E,E,3,[[["self"]],["str"]]],[11,R[37],E,E,0,[[["self"]],["str"]]],[11,R[37],E,E,1,[[["self"]],["str"]]],[11,R[37],E,E,2,[[["self"]],["str"]]]],"p":[[3,R[38]],[3,R[39]],[3,R[40]],[4,"Error"],[4,R[41]],[8,"Guard"],[3,R[42]],[3,R[43]],[3,R[44]],[3,R[45]],[3,R[46]]]};
initSearch(searchIndex);addSearchOptions(searchIndex);