var N=null,E="",T="t",U="u",searchIndex={};
var R=["safe_transmute","Transmute a byte slice into a sequence of values of the…","result","error","Transmute a byte slice into a single instance of a…","triviallytransmutable","unalignederror","Convert a byte slice into a single instance of a…","transmute_many","transmute_many_mut","transmute_many_permissive","View a byte slice as a slice of an arbitrary type.","transmute_vec","View a byte slice as a slice of boolean values.","copy_unchecked","Create a copy of the source data, transmuted into a…","Create a copy of the data, transmuted into a new vector.…","guarderror","Transmute the slice to a slice of another type, ensuring…","View a byte slice as a slice of a trivially transmutable…","Transform a vector into a vector of another element type.","Transmute a single instance of a trivially transmutable…","Transmute a slice of arbitrary types into a slice of their…","safe_transmute::error","to_owned","clone_into","to_string","try_from","borrow_mut","try_into","type_id","borrow","typeid","safe_transmute::guard","incompatiblevectargeterror","errorreason","formatter","description","GuardError","UnalignedError","IncompatibleVecTargetError","ErrorReason","SingleValueGuard","PedanticGuard","AllOrNothingGuard","SingleManyGuard","PermissiveGuard"];

searchIndex[R[0]]={"doc":"This crate contains checked implementations of…","i":[[5,"transmute_many_permissive_mut",R[0],R[1],N,[[],[[R[3],["u8"]],[R[2],[R[3]]]]]],[5,"transmute_many_pedantic_mut",E,R[1],N,[[],[[R[3],["u8"]],[R[2],[R[3]]]]]],[5,R[10],E,R[1],N,[[],[[R[2],[R[3]]],[R[3],["u8"]]]]],[5,"transmute_many_pedantic",E,R[1],N,[[],[[R[2],[R[3]]],[R[3],["u8"]]]]],[5,"transmute_one_pedantic",E,R[4],N,[[],[[R[2],[R[3]]],[R[5]],[R[3],["u8"]]]]],[5,R[8],E,R[1],N,[[],[[R[2],[R[3]]],[R[3],["u8"]]]]],[5,R[9],E,"Transmute a mutable byte slice into a mutable sequence of…",N,[[],[[R[3],["u8"]],[R[2],[R[3]]]]]],[5,"transmute_one",E,R[4],N,[[],[[R[2],[R[3]]],[R[5]],[R[3],["u8"]]]]],[5,R[12],E,"Transform a vector into a vector of values with the given…",N,[[[R[5]],["vec"]],[[R[2],["vec",R[3]]],["vec"],[R[3]]]]],[0,"align",E,"Alignment checking primitives.",N,N],[5,"check_alignment","safe_transmute::align","Check whether the given data slice of `S`s is properly…",N,[[],[[R[2],[R[6]]],[R[6]]]]],[5,"check_alignment_mut",E,"Check whether the given mutable data slice of `S`s is…",N,[[],[[R[2],[R[6]]],[R[6]]]]],[0,"base",R[0],"Primitives for object and array transmutation.",N,N],[5,"from_bytes","safe_transmute::base",R[7],N,[[],[[R[2],[R[3]]],[R[3],["u8"]],["copy"]]]],[5,"from_bytes_pedantic",E,R[7],N,[[],[[R[2],[R[3]]],[R[3],["u8"]],["copy"]]]],[5,R[8],E,R[11],N,[[],[[R[2],[R[3]]],[R[3],["u8"]]]]],[5,R[9],E,"View a mutable byte slice as a slice of an arbitrary type.",N,[[],[[R[3],["u8"]],[R[2],[R[3]]]]]],[5,R[10],E,R[11],N,[[]]],[5,R[12],E,R[20],N,[[["vec"]],["vec"]]],[0,"bool",R[0],"Functions for safe transmutation to `bool`.",N,N],[5,"bytes_are_bool","safe_transmute::bool","Makes sure that the bytes represent a sequence of valid…",N,[[],["bool"]]],[5,"transmute_bool_permissive",E,R[13],N,[[],[[R[2],[R[3]]],[R[3],["u8","bool"]]]]],[5,"transmute_bool_pedantic",E,R[13],N,[[],[[R[2],[R[3]]],[R[3],["u8","bool"]]]]],[5,"transmute_bool_vec_permissive",E,"Trasform a byte vector into a vector of bool.",N,[[["u8"],["vec",["u8"]]],[["vec",["bool"]],[R[2],["vec",R[3]]],[R[3],["u8","bool"]]]]],[5,"transmute_bool_vec_pedantic",E,"Transform a byte vector into a vector of bool.",N,[[["u8"],["vec",["u8"]]],[["vec",["bool"]],[R[2],["vec",R[3]]],[R[3],["u8","bool"]]]]],[0,R[3],R[0],"Detectable and recoverable-from transmutation precondition…",N,N],[3,R[38],R[23],"A slice boundary guard error, usually created by a `Guard`.",N,N],[12,"required",E,"The required amount of bytes for transmutation.",0,N],[12,"actual",E,"The actual amount of bytes.",0,N],[12,"reason",E,"Why this `required`/`actual`/`T` combo is an error.",0,N],[3,R[39],E,"Unaligned memory access error.",N,N],[12,"offset",E,"The required amount of bytes to discard at the front for…",1,N],[12,"source",E,"A slice of the original source data.",1,N],[3,R[40],E,"Incompatible vector transmutation error.",N,N],[12,"vec",E,"The original vector.",2,N],[4,"Error",E,"A transmutation error. This type describes possible errors…",N,N],[13,"Guard",E,"The data does not respect the target type's boundaries.",3,N],[13,"Unaligned",E,"The given data slice is not properly aligned for the…",3,N],[13,"IncompatibleVecTarget",E,"The data vector's element type does not have the same size…",3,N],[13,"InvalidValue",E,"The data contains an invalid value for the target type.",3,N],[4,R[41],E,"How the type's size compares to the received byte count…",N,N],[13,"NotEnoughBytes",E,"Too few bytes to fill even one instance of a type.",4,N],[13,"TooManyBytes",E,"Too many bytes to fill a type.",4,N],[13,"InexactByteCount",E,"The byte amount received is not the same as the type's size.",4,N],[11,"copy",E,"Reattempt the failed transmutation if the failure was…",3,[[],[[R[2],["vec",R[3]]],[R[3]],["vec"]]]],[11,R[14],E,"Reattempt the failed non-trivial transmutation if the…",3,[[],[[R[2],["vec",R[3]]],[R[3]],["vec"]]]],[11,"without_src",E,"Create a new error which discards runtime information…",3,[[],[R[3]]]],[11,R[37],E,"Retrieve a human readable description of the reason.",4,[[],["str"]]],[11,"new",E,E,1,[[["usize"]],["self"]]],[11,R[14],E,R[15],1,[[["self"]],["vec"]]],[11,"copy",E,R[15],1,[[["self"]],["vec"]]],[11,"new",E,"Create an error with the given vector.",2,[[["vec"]],["self"]]],[11,R[14],E,R[16],2,[[["self"]],["vec"]]],[11,"copy",E,R[16],2,[[["self"]],["vec"]]],[0,"guard",R[0],"The `guard` module exposes an API for memory boundary…",N,N],[3,R[42],R[33],"Single value guard: The byte slice must have exactly…",N,N],[3,R[43],E,"Pedantic guard: The byte slice must have at least enough…",N,N],[3,R[44],E,"An all-or-nothing guard: The byte slice should not have…",N,N],[3,R[45],E,"A single-or-many guard: The byte slice must have at least…",N,N],[3,R[46],E,"Permissive guard: The resulting slice would have as many…",N,N],[8,"Guard",E,"The trait describes types which define boundary checking…",N,N],[10,"check",E,"Check the size of the given byte slice against a…",5,[[],[[R[2],[R[17]]],[R[17]]]]],[0,"trivial",R[0],"Transmutation of trivial objects",N,N],[5,"align_to","safe_transmute::trivial",R[18],N,[[]]],[5,"align_to_mut",E,R[18],N,[[]]],[5,"transmute_trivial",E,R[4],N,[[],[[R[2],[R[3]]],[R[5]],[R[3],["u8"]]]]],[5,"transmute_trivial_pedantic",E,R[4],N,[[],[[R[2],[R[3]]],[R[5]],[R[3],["u8"]]]]],[5,"transmute_trivial_many",E,R[4],N,[[],[[R[2],[R[3]]],[R[3],["u8"]]]]],[5,"transmute_trivial_many_mut",E,R[4],N,[[],[[R[3],["u8"]],[R[2],[R[3]]]]]],[5,"guarded_transmute_pod_many_permissive",E,R[19],N,[[],[[R[2],[R[3]]],[R[3],["u8"]]]]],[5,"guarded_transmute_pod_many_pedantic",E,R[19],N,[[],[[R[2],[R[3]]],[R[3],["u8"]]]]],[5,"transmute_trivial_vec",E,R[20],N,[[[R[5]],["vec"]],[[R[5]],["vec"]]]],[8,"TriviallyTransmutable",E,"Type that can be constructed from any combination of bytes.",N,N],[0,"util",R[0],"Module containing various utility functions.",N,N],[5,"designalise_f32","safe_transmute::util","If the specified 32-bit float is a signaling NaN, make it…",N,[[["f32"]],["f32"]]],[5,"designalise_f64",E,"If the specified 64-bit float is a signaling NaN, make it…",N,[[["f64"]],["f64"]]],[5,"from_bits_f32_designalised",E,"Reinterpret the given bits as a 32-bit float. If the…",N,[[["u32"]],["f32"]]],[5,"from_bits_f64_designalised",E,"Reinterpret the given bits as a 64-bit float. If the…",N,[[["u64"]],["f64"]]],[0,"to_bytes",R[0],"Functions for transmutation from a concrete type to bytes.",N,N],[5,"transmute_to_bytes_unchecked","safe_transmute::to_bytes","Transmute a single instance of an arbitrary type into a…",N,[[["s"]]]],[5,"transmute_to_bytes_unchecked_mut",E,"Transmute a single mutable instance of an arbitrary type…",N,[[["s"]]]],[5,"transmute_to_bytes_many_unchecked",E,R[22],N,[[]]],[5,"transmute_to_bytes_many_unchecked_mut",E,"Transmute a mutable slice of arbitrary types into a…",N,[[]]],[5,"transmute_one_to_bytes",E,R[21],N,[[["s"]]]],[5,"transmute_one_to_bytes_mut",E,R[21],N,[[["s"]]]],[5,"transmute_to_bytes",E,R[22],N,[[]]],[5,"transmute_to_bytes_mut",E,"Transmute a mutable slice of a trivially transmutable type…",N,[[]]],[5,"guarded_transmute_to_bytes_pod_many",E,R[22],N,[[]]],[5,"transmute_to_bytes_vec",E,"Transmute a vector of elements of an arbitrary type into a…",N,[[[R[5]],["vec"]],[[R[2],["vec",R[3]]],[R[3],["u8"]],["vec",["u8"]]]]],[14,"try_copy",R[0],"Retrieve the result of a transmutation, copying the data…",N,N],[14,"try_copy_unchecked",E,"Retrieve the result of a non-trivial transmutation,…",N,N],[11,"from",R[23],E,0,[[[T]],[T]]],[11,"into",E,E,0,[[],[U]]],[11,R[24],E,E,0,[[["self"]],[T]]],[11,R[25],E,E,0,[[[T],["self"]]]],[11,R[26],E,E,0,[[["self"]],["string"]]],[11,R[27],E,E,0,[[[U]],[R[2]]]],[11,R[31],E,E,0,[[["self"]],[T]]],[11,R[30],E,E,0,[[["self"]],[R[32]]]],[11,R[28],E,E,0,[[["self"]],[T]]],[11,R[29],E,E,0,[[],[R[2]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,"into",E,E,1,[[],[U]]],[11,R[24],E,E,1,[[["self"]],[T]]],[11,R[25],E,E,1,[[[T],["self"]]]],[11,R[26],E,E,1,[[["self"]],["string"]]],[11,R[27],E,E,1,[[[U]],[R[2]]]],[11,R[31],E,E,1,[[["self"]],[T]]],[11,R[30],E,E,1,[[["self"]],[R[32]]]],[11,R[28],E,E,1,[[["self"]],[T]]],[11,R[29],E,E,1,[[],[R[2]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,"into",E,E,2,[[],[U]]],[11,R[24],E,E,2,[[["self"]],[T]]],[11,R[25],E,E,2,[[[T],["self"]]]],[11,R[26],E,E,2,[[["self"]],["string"]]],[11,R[27],E,E,2,[[[U]],[R[2]]]],[11,R[31],E,E,2,[[["self"]],[T]]],[11,R[30],E,E,2,[[["self"]],[R[32]]]],[11,R[28],E,E,2,[[["self"]],[T]]],[11,R[29],E,E,2,[[],[R[2]]]],[11,"from",E,E,3,[[[T]],[T]]],[11,"into",E,E,3,[[],[U]]],[11,R[24],E,E,3,[[["self"]],[T]]],[11,R[25],E,E,3,[[[T],["self"]]]],[11,R[26],E,E,3,[[["self"]],["string"]]],[11,R[27],E,E,3,[[[U]],[R[2]]]],[11,R[31],E,E,3,[[["self"]],[T]]],[11,R[30],E,E,3,[[["self"]],[R[32]]]],[11,R[28],E,E,3,[[["self"]],[T]]],[11,R[29],E,E,3,[[],[R[2]]]],[11,"from",E,E,4,[[[T]],[T]]],[11,"into",E,E,4,[[],[U]]],[11,R[24],E,E,4,[[["self"]],[T]]],[11,R[25],E,E,4,[[[T],["self"]]]],[11,R[27],E,E,4,[[[U]],[R[2]]]],[11,R[31],E,E,4,[[["self"]],[T]]],[11,R[30],E,E,4,[[["self"]],[R[32]]]],[11,R[28],E,E,4,[[["self"]],[T]]],[11,R[29],E,E,4,[[],[R[2]]]],[11,"from",R[33],E,6,[[[T]],[T]]],[11,"into",E,E,6,[[],[U]]],[11,R[27],E,E,6,[[[U]],[R[2]]]],[11,R[31],E,E,6,[[["self"]],[T]]],[11,R[30],E,E,6,[[["self"]],[R[32]]]],[11,R[28],E,E,6,[[["self"]],[T]]],[11,R[29],E,E,6,[[],[R[2]]]],[11,"from",E,E,7,[[[T]],[T]]],[11,"into",E,E,7,[[],[U]]],[11,R[27],E,E,7,[[[U]],[R[2]]]],[11,R[31],E,E,7,[[["self"]],[T]]],[11,R[30],E,E,7,[[["self"]],[R[32]]]],[11,R[28],E,E,7,[[["self"]],[T]]],[11,R[29],E,E,7,[[],[R[2]]]],[11,"from",E,E,8,[[[T]],[T]]],[11,"into",E,E,8,[[],[U]]],[11,R[27],E,E,8,[[[U]],[R[2]]]],[11,R[31],E,E,8,[[["self"]],[T]]],[11,R[30],E,E,8,[[["self"]],[R[32]]]],[11,R[28],E,E,8,[[["self"]],[T]]],[11,R[29],E,E,8,[[],[R[2]]]],[11,"from",E,E,9,[[[T]],[T]]],[11,"into",E,E,9,[[],[U]]],[11,R[27],E,E,9,[[[U]],[R[2]]]],[11,R[31],E,E,9,[[["self"]],[T]]],[11,R[30],E,E,9,[[["self"]],[R[32]]]],[11,R[28],E,E,9,[[["self"]],[T]]],[11,R[29],E,E,9,[[],[R[2]]]],[11,"from",E,E,10,[[[T]],[T]]],[11,"into",E,E,10,[[],[U]]],[11,R[27],E,E,10,[[[U]],[R[2]]]],[11,R[31],E,E,10,[[["self"]],[T]]],[11,R[30],E,E,10,[[["self"]],[R[32]]]],[11,R[28],E,E,10,[[["self"]],[T]]],[11,R[29],E,E,10,[[],[R[2]]]],[11,"check",E,E,6,[[],[[R[2],[R[17]]],[R[17]]]]],[11,"check",E,E,7,[[],[[R[2],[R[17]]],[R[17]]]]],[11,"check",E,E,8,[[],[[R[2],[R[17]]],[R[17]]]]],[11,"check",E,E,9,[[],[[R[2],[R[17]]],[R[17]]]]],[11,"check",E,E,10,[[],[[R[2],[R[17]]],[R[17]]]]],[11,"eq",R[23],E,3,[[["self"],[R[3]]],["bool"]]],[11,"ne",E,E,3,[[["self"],[R[3]]],["bool"]]],[11,"eq",E,E,0,[[[R[17]],["self"]],["bool"]]],[11,"ne",E,E,0,[[[R[17]],["self"]],["bool"]]],[11,"eq",E,E,4,[[[R[35]],["self"]],["bool"]]],[11,"eq",E,E,1,[[[R[6]],["self"]],["bool"]]],[11,"ne",E,E,1,[[[R[6]],["self"]],["bool"]]],[11,"eq",E,E,2,[[[R[34]],["self"]],["bool"]]],[11,"ne",E,E,2,[[[R[34]],["self"]],["bool"]]],[11,"clone",E,E,3,[[["self"]],[R[3]]]],[11,"clone",E,E,0,[[["self"]],[R[17]]]],[11,"clone",E,E,4,[[["self"]],[R[35]]]],[11,"clone",E,E,1,[[["self"]],[R[6]]]],[11,"clone",E,E,2,[[["self"]],[R[34]]]],[11,"from",E,E,3,[[[R[17]]],["self"]]],[11,"from",E,E,3,[[[R[6]]],["self"]]],[11,"from",E,E,3,[[[R[34]]],["self"]]],[11,"fmt",E,E,3,[[[R[36]],["self"]],[R[2]]]],[11,"fmt",E,E,0,[[[R[36]],["self"]],[R[2]]]],[11,"fmt",E,E,4,[[[R[36]],["self"]],[R[2]]]],[11,"fmt",E,E,1,[[[R[36]],["self"]],[R[2]]]],[11,"fmt",E,E,2,[[[R[36]],["self"]],[R[2]]]],[11,"fmt",E,E,3,[[[R[36]],["self"]],[R[2]]]],[11,"fmt",E,E,0,[[[R[36]],["self"]],[R[2]]]],[11,"fmt",E,E,1,[[[R[36]],["self"]],[R[2]]]],[11,"fmt",E,E,2,[[[R[36]],["self"]],[R[2]]]],[11,"hash",E,E,3,[[["__hst"],["self"]]]],[11,"hash",E,E,0,[[["self"],["__h"]]]],[11,"hash",E,E,4,[[["self"],["__h"]]]],[11,"hash",E,E,1,[[["__hst"],["self"]]]],[11,"hash",E,E,2,[[["__hst"],["self"]]]],[11,R[37],E,E,3,[[["self"]],["str"]]],[11,R[37],E,E,0,[[["self"]],["str"]]],[11,R[37],E,E,1,[[["self"]],["str"]]],[11,R[37],E,E,2,[[["self"]],["str"]]]],"p":[[3,R[38]],[3,R[39]],[3,R[40]],[4,"Error"],[4,R[41]],[8,"Guard"],[3,R[42]],[3,R[43]],[3,R[44]],[3,R[45]],[3,R[46]]]};
initSearch(searchIndex);addSearchOptions(searchIndex);